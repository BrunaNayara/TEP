\section{Travessias em árvores}

\begin{frame}[fragile]{DFS em árvores}

    \begin{itemize}
        \item Embora a DFS e a BFS possa ser utilizadas em árvores sem nenhuma alteração,
            a estrutura simplificada da árvore permite implementações mais simples e com
            menor complexidade de memória
            
        \item Por conta da ausência de ciclos, a implementação da DFS em árvores dispensa o
            vetor que mantém o registro dos vértices já visitados

        \item Ele pode ser substituído por um parâmetro extra, que mantém o registro do nó $p$ que
            antecede $u$ na travessia

        \item Assim, a complexidade de memória reduz de $O(V)$ para $O(1)$

        \item Na primeira chamada da DFS, o parâmetro $p$ deve ser igual a zero (ou qualquer
            valor sentinela que não seja um rótulo de um dos vértices do grafo)
    \end{itemize}

\end{frame}

\begin{frame}[fragile]{Implementação da DFS em árvores}
    \inputsnippet{c++}{1}{17}{tree_dfs.cpp}
\end{frame}

\begin{frame}[fragile]{Implementação da DFS em árvores}
    \inputsnippet{c++}{18}{38}{tree_dfs.cpp}
\end{frame}

\begin{frame}[fragile]{Números de nós na subárvore}

    \begin{itemize}
        \item A DFS, em conjunto com técnicas de programação dinâmica, permite computar em
            $O(N)$ algumas características da árvore

        \item Um primeiro exemplo seria o número de nós $n(u)$ da subárvore cuja raiz é o nó $u$

        \item Se $u$ é uma folha, então $n(u) = 1$ (apenas $u$ faz parte da subárvore)

        \item Caso contrário, $n(u) = 1 + \sum_v n(v)$, onde $v$ é um filho de $u$
    \end{itemize}

\end{frame}

\begin{frame}[fragile]{Implementação da rotina que computa $n(u)$}
    \inputsnippet{c++}{1}{21}{n.cpp}
\end{frame}

\begin{frame}[fragile]{Implementação da rotina que computa $n(u)$}
    \inputsnippet{c++}{22}{42}{n.cpp}
\end{frame}

\begin{frame}[fragile]{Maior caminho até uma folha}

    \begin{itemize}
        \item Outro exemplo de DFS com DP é o cálculo do tamanho (em número de arestas) do
            maior caminho $d(u)$ de $u$ até uma folha

        \item Se $u$ for uma folha então $d(u) = 0$

        \item Caso contrário, $d(u) = 1 + \max \lbrace d(v_i) \rbrace$, onde $v_i$ são os 
            filhos de $u$

        \item Esta rotina pode ser facilmente adaptada para retornar o tamanho como a soma dos
            pesos das arestas
    \end{itemize}

\end{frame}

\begin{frame}[fragile]{Implementação da rotina que computa $d(u)$}
    \inputsnippet{c++}{1}{21}{d.cpp}
\end{frame}

\begin{frame}[fragile]{Implementação da rotina que computa $d(u)$}
    \inputsnippet{c++}{22}{42}{d.cpp}
\end{frame}
